<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Korean DOM Manipulation Test</title>
    <style>
        body {
            font-family: 'Apple SD Gothic Neo', 'Malgun Gothic', 'ÎßëÏùÄ Í≥†Îîï', 'Noto Sans CJK KR', 'D2Coding', sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .test-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        textarea {
            width: 100%;
            height: 60px;
            font-size: 18px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: 'Apple SD Gothic Neo', 'Malgun Gothic', 'ÎßëÏùÄ Í≥†Îîï', 'Noto Sans CJK KR', 'D2Coding', sans-serif;
        }
        button {
            margin: 5px;
            padding: 8px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .result {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 3px;
            font-family: monospace;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>üß™ Korean DOM Manipulation Test</h1>
    <p>Testing different approaches to make archaic jamo render as combined blocks when typed.</p>

    <div class="test-section">
        <div class="test-title">Test 1: Direct Value Assignment</div>
        <textarea id="test1" placeholder="Type here..."></textarea>
        <button onclick="testDirectValue()">Test Direct Value</button>
        <div id="result1" class="result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 2: InsertText API</div>
        <textarea id="test2" placeholder="Type here..."></textarea>
        <button onclick="testInsertText()">Test InsertText</button>
        <div id="result2" class="result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 3: execCommand</div>
        <textarea id="test3" placeholder="Type here..."></textarea>
        <button onclick="testExecCommand()">Test execCommand</button>
        <div id="result3" class="result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 4: DocumentFragment</div>
        <textarea id="test4" placeholder="Type here..."></textarea>
        <button onclick="testDocumentFragment()">Test DocumentFragment</button>
        <div id="result4" class="result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 5: Input Event Simulation</div>
        <textarea id="test5" placeholder="Type here..."></textarea>
        <button onclick="testInputEvent()">Test Input Event</button>
        <div id="result5" class="result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 6: Composition Event</div>
        <textarea id="test6" placeholder="Type here..."></textarea>
        <button onclick="testCompositionEvent()">Test Composition Event</button>
        <div id="result6" class="result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Test 7: Multiple Approaches Combined</div>
        <textarea id="test7" placeholder="Type here..."></textarea>
        <button onclick="testCombined()">Test Combined</button>
        <div id="result7" class="result"></div>
    </div>

    <div class="test-section">
        <div class="test-title">Reference: Pasted Text (Should Render as Block)</div>
        <textarea id="reference" placeholder="Paste ·ÖÄ·Ö°·Ü´ here to see expected result..."></textarea>
        <div id="reference-result" class="result">Paste ·ÖÄ·Ö°·Ü´ here to see how it should look</div>
    </div>

    <script>
        const archaicJamo = '·ÖÄ„Öè„Ñ¥'; // The sequence we want to render as a block
        const expectedBlock = '·ÖÄ·Ö°·Ü´'; // How it should look when rendered

        function logResult(testId, method, success, details) {
            const resultDiv = document.getElementById(`result${testId}`);
            const className = success ? 'success' : 'error';
            resultDiv.className = `result ${className}`;
            resultDiv.innerHTML = `
                <strong>${method}:</strong> ${success ? 'SUCCESS' : 'FAILED'}<br>
                <strong>Details:</strong> ${details}
            `;
        }

        function testDirectValue() {
            const textarea = document.getElementById('test1');
            const cursorPos = textarea.selectionStart;
            
            try {
                // Method 1: Direct value assignment
                textarea.value = textarea.value.slice(0, cursorPos) + archaicJamo + textarea.value.slice(cursorPos);
                textarea.setSelectionRange(cursorPos + archaicJamo.length, cursorPos + archaicJamo.length);
                textarea.focus();
                
                // Check if it rendered as a block
                const rendered = textarea.value.slice(cursorPos, cursorPos + archaicJamo.length);
                const success = rendered === expectedBlock;
                logResult(1, 'Direct Value Assignment', success, 
                    `Rendered: "${rendered}" (${rendered.length} chars), Expected: "${expectedBlock}"`);
            } catch (error) {
                logResult(1, 'Direct Value Assignment', false, `Error: ${error.message}`);
            }
        }

        function testInsertText() {
            const textarea = document.getElementById('test2');
            
            try {
                // Method 2: InsertText API (if supported)
                if (document.execCommand) {
                    textarea.focus();
                    document.execCommand('insertText', false, archaicJamo);
                    
                    // Check result
                    const success = textarea.value.includes(expectedBlock);
                    logResult(2, 'InsertText API', success, 
                        `Textarea contains expected block: ${success}`);
                } else {
                    logResult(2, 'InsertText API', false, 'InsertText API not supported');
                }
            } catch (error) {
                logResult(2, 'InsertText API', false, `Error: ${error.message}`);
            }
        }

        function testExecCommand() {
            const textarea = document.getElementById('test3');
            
            try {
                // Method 3: execCommand
                textarea.focus();
                const success = document.execCommand('insertText', false, archaicJamo);
                
                logResult(3, 'execCommand', success, 
                    `Command executed: ${success}, Text: "${textarea.value}"`);
            } catch (error) {
                logResult(3, 'execCommand', false, `Error: ${error.message}`);
            }
        }

        function testDocumentFragment() {
            const textarea = document.getElementById('test4');
            
            try {
                // Method 4: DocumentFragment
                const fragment = document.createDocumentFragment();
                const textNode = document.createTextNode(archaicJamo);
                fragment.appendChild(textNode);
                
                // This won't work directly with textarea, but let's try
                const cursorPos = textarea.selectionStart;
                textarea.value = textarea.value.slice(0, cursorPos) + archaicJamo + textarea.value.slice(cursorPos);
                textarea.setSelectionRange(cursorPos + archaicJamo.length, cursorPos + archaicJamo.length);
                
                logResult(4, 'DocumentFragment', true, 'Method attempted (limited with textarea)');
            } catch (error) {
                logResult(4, 'DocumentFragment', false, `Error: ${error.message}`);
            }
        }

        function testInputEvent() {
            const textarea = document.getElementById('test5');
            
            try {
                // Method 5: Input event simulation
                const cursorPos = textarea.selectionStart;
                textarea.value = textarea.value.slice(0, cursorPos) + archaicJamo + textarea.value.slice(cursorPos);
                textarea.setSelectionRange(cursorPos + archaicJamo.length, cursorPos + archaicJamo.length);
                
                // Dispatch input event
                const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                textarea.dispatchEvent(inputEvent);
                
                // Also try beforeinput
                const beforeInputEvent = new InputEvent('beforeinput', { 
                    bubbles: true, 
                    cancelable: true,
                    inputType: 'insertText',
                    data: archaicJamo
                });
                textarea.dispatchEvent(beforeInputEvent);
                
                logResult(5, 'Input Event Simulation', true, 'Events dispatched');
            } catch (error) {
                logResult(5, 'Input Event Simulation', false, `Error: ${error.message}`);
            }
        }

        function testCompositionEvent() {
            const textarea = document.getElementById('test6');
            
            try {
                // Method 6: Composition events
                textarea.focus();
                
                // Start composition
                const compositionStartEvent = new CompositionEvent('compositionstart', { bubbles: true });
                textarea.dispatchEvent(compositionStartEvent);
                
                // Update composition
                const compositionUpdateEvent = new CompositionEvent('compositionupdate', { 
                    bubbles: true,
                    data: archaicJamo
                });
                textarea.dispatchEvent(compositionUpdateEvent);
                
                // Insert the text
                const cursorPos = textarea.selectionStart;
                textarea.value = textarea.value.slice(0, cursorPos) + archaicJamo + textarea.value.slice(cursorPos);
                textarea.setSelectionRange(cursorPos + archaicJamo.length, cursorPos + archaicJamo.length);
                
                // End composition
                const compositionEndEvent = new CompositionEvent('compositionend', { 
                    bubbles: true,
                    data: archaicJamo
                });
                textarea.dispatchEvent(compositionEndEvent);
                
                logResult(6, 'Composition Event', true, 'Composition events dispatched');
            } catch (error) {
                logResult(6, 'Composition Event', false, `Error: ${error.message}`);
            }
        }

        function testCombined() {
            const textarea = document.getElementById('test7');
            
            try {
                // Method 7: Combined approach
                textarea.focus();
                
                // Use setTimeout to ensure proper timing
                setTimeout(() => {
                    const cursorPos = textarea.selectionStart;
                    
                    // Try multiple methods in sequence
                    textarea.value = textarea.value.slice(0, cursorPos) + archaicJamo + textarea.value.slice(cursorPos);
                    textarea.setSelectionRange(cursorPos + archaicJamo.length, cursorPos + archaicJamo.length);
                    
                    // Force re-render
                    textarea.style.display = 'none';
                    textarea.offsetHeight; // Trigger reflow
                    textarea.style.display = '';
                    
                    // Dispatch events
                    const inputEvent = new Event('input', { bubbles: true });
                    textarea.dispatchEvent(inputEvent);
                    
                    // Blur and focus to force re-render
                    textarea.blur();
                    setTimeout(() => {
                        textarea.focus();
                        logResult(7, 'Combined Approach', true, 'Multiple methods applied');
                    }, 10);
                }, 0);
            } catch (error) {
                logResult(7, 'Combined Approach', false, `Error: ${error.message}`);
            }
        }

        // Monitor reference textarea for pasted content
        document.getElementById('reference').addEventListener('paste', function(e) {
            setTimeout(() => {
                const result = this.value;
                const resultDiv = document.getElementById('reference-result');
                resultDiv.className = 'result success';
                resultDiv.innerHTML = `<strong>Pasted Result:</strong> "${result}" (${result.length} chars)`;
            }, 10);
        });

        // Add event listeners to all textareas to monitor changes
        document.querySelectorAll('textarea').forEach((textarea, index) => {
            textarea.addEventListener('input', function() {
                console.log(`Textarea ${index + 1} changed:`, this.value);
            });
        });
    </script>
</body>
</html>
